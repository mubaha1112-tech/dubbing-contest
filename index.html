<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Firstleap Voice Magic（含片头修复版）</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f7f3ea;
      font-family: Arial, Helvetica, sans-serif;
    }
    .container {
      max-width: 720px;
      margin: auto;
      padding: 16px;
    }
    video {
      width: 100%;
      border-radius: 12px;
      background: #000;
    }
    button, select {
      padding: 10px 16px;
      font-size: 16px;
      border: none;
      background: #e74c3c;
      color: #fff;
      border-radius: 10px;
      margin-right: 10px;
    }
    #downloadLink {
      display: none;
      font-size: 16px;
      margin-top: 12px;
      color: #2980b9;
    }
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
  </style>
</head>

<body>
<div class="container">

  <h2>Firstleap Voice Magic（含片头 + 安卓 Chrome 修复版）</h2>

  <label>选择视频：</label>
  <select id="videoSelect">
    <option value="">请选择视频</option>
    <option value="https://file-aliyun.firstleap.cn/homework/teacher/video/20251113/1763011941537284494.mp4">示例视频 1</option>
    <option value="https://file-aliyun.firstleap.cn/homework/teacher/video/20251113/17630119516450a277c.mp4">示例视频 2</option>
  </select>
  <button id="loadBtn">加载视频</button>

  <br/><br/>

  <video id="mainVideo" controls playsinline webkit-playsinline></video>

  <br/><br/>

  <button id="startBtn" disabled>开始录制（含片头）</button>
  <button id="stopBtn" disabled>停止录制</button>

  <br/>

  <a id="downloadLink">点击下载视频</a>

  <div id="overlay">正在处理，请稍候…</div>

</div>

<script>
/* 核心修复逻辑说明（非常重要）：

  ❗ 加入片头 intro.png 后，你原来的代码改成了 canvas.captureStream()，
     导致 Android Chrome 下录制只有 1 秒黑屏。
     因为 canvas 第一帧是静态 PNG，会让 video track 冻结（Android Chrome 的 bug）。

  ✔ 新方案：
     1. 生成一个“真正的视频片头 intro 段”，长度 1 秒。
     2. 使用 MediaStreamTrackGenerator 生成 intro 段（没有 canvas）。
     3. 把 introVideoTrack + mainVideoTrack + audioTrack 合并。
     4. 整个录制仍然用 MediaRecorder，最终可正常播放。

  ✔ 这样 intro.png 仍然作为片头，且不会导致黑屏。
*/

// DOM 获取
const videoSelect = document.getElementById("videoSelect");
const loadBtn = document.getElementById("loadBtn");
const mainVideo = document.getElementById("mainVideo");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const downloadLink = document.getElementById("downloadLink");
const overlay = document.getElementById("overlay");

let micStream = null;
let finalRecorder = null;
let recordedChunks = [];
let finalStream = null;
let audioCtx = null;

// 加载视频
loadBtn.onclick = () => {
  const url = videoSelect.value;
  if (!url) return alert("请选择视频");
  mainVideo.src = url;
  mainVideo.load();
  mainVideo.oncanplay = () => {
    startBtn.disabled = false;
  };
};

// 麦克风权限
async function getMic() {
  if (micStream) return micStream;
  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  return micStream;
}

// **生成片头 intro 视频轨**
async function createIntroTrack() {
  const track = new MediaStreamTrackGenerator({ kind: "video" });
  const writer = track.writable.getWriter();

  const introImg = await loadImage("intro.png");

  const w = 720, h = 1280;  // 固定尺寸，避免 canvas.captureStream 的问题
  const frameDuration = 33_000; // 30fps（单位 microseconds）

  // ❗ 直接生成 RGBA 帧，而不是 canvas（避免 Android Chrome 冻结）
  const bitmap = await createImageBitmap(introImg, { resizeWidth: w, resizeHeight: h });

  const off = new OffscreenCanvas(w, h);
  const ctx = off.getContext("2d");

  ctx.drawImage(bitmap, 0, 0, w, h);
  const frame = new VideoFrame(off, { timestamp: 0 });

  // 写入 1 秒约 30 帧
  for (let i = 0; i < 30; i++) {
    await writer.write(new VideoFrame(off, { timestamp: i * frameDuration }));
  }

  writer.close();
  return track;
}

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.src = src + "?v=" + Date.now(); 
    img.onload = () => resolve(img);
    img.onerror = reject;
  });
}
// ------------------------------------------------------
// 主视频轨道（使用 video.captureStream）
// ------------------------------------------------------
async function getMainVideoTrack() {
  // 需要先播放一下，部分浏览器要求 play 后才能 captureStream
  try {
    await mainVideo.play();
    mainVideo.pause();
  } catch(e) {}

  if (typeof mainVideo.captureStream === "function") {
    const vs = mainVideo.captureStream(30);
    return vs.getVideoTracks()[0];
  }

  alert("你的浏览器不支持 captureStream()");
  throw new Error("no captureStream");
}

// ------------------------------------------------------
// 音频混合（视频音频 + 麦克风）
// ------------------------------------------------------
async function buildAudioTrack() {
  if (!audioCtx) {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
  }

  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
  }

  const mic = await getMic();
  const micSource = audioCtx.createMediaStreamSource(mic);

  // 视频音频
  let videoSource = null;
  try {
    videoSource = audioCtx.createMediaElementSource(mainVideo);
  } catch (e) {
    console.warn("视频音频无法接入（可能 CORS）→ 仅使用麦克风", e);
  }

  const dest = audioCtx.createMediaStreamDestination();

  // 麦克风输出
  micSource.connect(dest);

  // 视频原声（若 CORS 允许）
  if (videoSource) {
    videoSource.connect(dest);
  }

  return dest.stream.getAudioTracks()[0];
}

// ------------------------------------------------------
// 开始录制
// ------------------------------------------------------
startBtn.onclick = async () => {
  startBtn.disabled = true;
  stopBtn.disabled = false;
  downloadLink.style.display = "none";
  overlay.style.display = "flex";

  recordedChunks = [];

  // 1. intro 片头视频轨
  const introTrack = await createIntroTrack();

  // 2. 真实视频的 video track
  const mainTrack = await getMainVideoTrack();

  // 3. 音频 track
  const audioTrack = await buildAudioTrack();

  // 4. 合成最终 MediaStream
  finalStream = new MediaStream([introTrack, mainTrack, audioTrack]);

  // 选择最兼容的 mimeType（Android Chrome）
  let mimeType = "";
  const candidates = [
    "video/webm;codecs=vp9,opus",
    "video/webm;codecs=vp8,opus",
    "video/webm"
  ];
  for (const c of candidates) {
    if (MediaRecorder.isTypeSupported(c)) {
      mimeType = c;
      break;
    }
  }

  const options = mimeType ? { mimeType } : {};

  // MediaRecorder
  finalRecorder = new MediaRecorder(finalStream, options);

  finalRecorder.ondataavailable = (e) => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };

  finalRecorder.onstop = handleFinish;

  finalRecorder.start(200); // 每 200ms 切片
  overlay.style.display = "none";

  // 真实视频从头播放
  mainVideo.currentTime = 0;
  mainVideo.play().catch(()=>{});
};

// ------------------------------------------------------
// 停止录制
// ------------------------------------------------------
stopBtn.onclick = () => {
  stopBtn.disabled = true;
  overlay.style.display = "flex";
  finalRecorder.stop();

  // 停止所有 track
  finalStream.getTracks().forEach(t => t.stop());
};

// ------------------------------------------------------
// 合成完成 → 下载文件
// ------------------------------------------------------
function handleFinish() {
  overlay.style.display = "none";

  const blob = new Blob(recordedChunks, { type: finalRecorder.mimeType || "video/webm" });

  if (blob.size < 2000) {
    alert("录制失败：生成文件太小，可能被系统限制或视频源 CORS 失败。");
    startBtn.disabled = false;
    return;
  }

  const url = URL.createObjectURL(blob);
  const filename = "Firstleap_Dub_" + Date.now() + ".webm";

  downloadLink.href = url;
  downloadLink.download = filename;
  downloadLink.style.display = "inline-block";
  downloadLink.innerText = "点击下载最终视频（含片头）";

  // 允许重新录制
  startBtn.disabled = false;
  overlay.style.display = "none";
}

// ------------------------------------------------------
// 页面关闭前清理
// ------------------------------------------------------
window.addEventListener("beforeunload", () => {
  try {
    if (micStream) micStream.getTracks().forEach(t => t.stop());
    if (finalStream) finalStream.getTracks().forEach(t => t.stop());
  } catch(e) {}
});
</script>

</body>
</html>
